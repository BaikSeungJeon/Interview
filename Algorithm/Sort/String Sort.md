[1. Naive(순진한)](#1-naive-순진한)

[2. Rabin-Karp(라빈 카프)](#2-rabin-karp-라빈-카프)

[3. KMP](#3-kmp)

[4. Boyer Moore(보이어-무어)](#4-boyer-moore보이어-무어)

- ### 1. Naive (순진한)
    - Naive 방식은 본문 처음부터 끝까지 문자 하나하나씩 패턴과 비교하여 찾습니다.
    - 문자열 알고리즘에서 최악을 성능을 가지므로 많이 사용하진 않습니다.
    - 다른 문자열 검색 알고리즘이 정상적으로 구현되었는지 확인하기 위한 표본으로 사용하는데 유용합니다.
    - O(n * m) (n : 본문 길이, m : 패턴 길이)
    
- ### 2. Rabin-Karp (라빈 카프)
  - 본문에서 차례대로 패턴 크기만큼 문자열의 해시값을 구하고 미리 구해놓은 패턴의 해시값을 비교해 봅니다.
  - 라빈 카프 알고리즘에 사용되는 해시 함수는 다음과 같이 연산을 수행합니다.
  - **abacaaba의 해시 값**
      ```
      =  97 * 2^7 +
      98 * 2^6 +
      97 * 2^5 +
      99 * 2^4 +
      97 * 2^3 +
      97 * 2^2 +
      98 * 2^1 +
      97 * 2^0
      = 24,833
      ```
  - 쉽게 말해 **각 문자의 아스키 코드 값에 2의 제곱 수를 차례대로 곱하여 더해준 것**입니다.
  - 보시면 문자열이 달라지면 결과로 출력되는 해시 값도 바뀌는 것을 알 수 있습니다.
  - **물론 해시 값이 중복되는 경우도 발생**할 수 있습니다. 이것을 **충돌(Collision)**이라고 하는데, 보통 발생률이 높지 않기 때문에 무시하고 넘어가는 것입니다.
  실제로는 충돌이 발생하는 경우 포인터(Pointer)를 이용해 연결 자료구조를 이용해 해결합니다.
  - 하지만 냉정하게 생각했을떄 Naive방식과 별다를것이 없는데 실제론 더 빠릅니다.
  - 그 이유는 본문에서 검사할 문자열을 변경할때 일어나는데 문자열을 한칸씩 오른쪽으로 이동하면서 비교하기 때문에 기존의 문자열 해쉬값에서 맨왼쪽값을 빼주고 맨오른쪽해쉬값을 더해주면 되기 때문이죠 이때 남아있던 문자열에 *2를 해줘야하는데 그 이유는 한칸씩 옮겨지기 때문에 2제곱수가 하나씩 올라가기 때문입니다.
  - O(n + m)이 되겠다. (n : 본문 길이, m : 패턴 길이)

- ### 3. KMP
    - KMP 알고리즘은 접두사와 접미사의 개념을 활용하여 '반복되는 연산을 얼마나 줄일 수 있는지'를 판별하여 매칭할 문자열을 빠르게 점프하는 기법입니다. 일단 접두사와 접미사는 말 그대로 앞에 있는 문자열과 뒤에 있는 문자열을 의미합니다. 예를 들어 abacaaba가 있을 때 다음과 같습니다.
    - **접두사** **접미사**

        **a b a** c a **a b a**

    - 접두사와 접미사의 최대 일치 길이는 3인것을 알 수가 있습니다.
    
    - 실행 순서
   
          1. 본문 문자열에 접두사와 접미사가 일치하는 문자열을 검사합니다.
          2. 검사 결과 일치하지 않으면 본문 문자열의 접미사를 접두사로 옮겨서 문자열 검사를 합니다.
          3. 반복
        
    - O(n)

- ### 4. Boyer Moore(보이어-무어)
    - 매번 문자열을 검사할때 문자열을 뒤에서부터 검사하는 방식을 사용합니다.
    - 검사방식은 나쁜문자 이동, 착한접미부 이동 2가지 방식을 사용합니다.
       
       ![2](https://user-images.githubusercontent.com/75124028/195821382-3b77306f-c269-40c5-abab-74d7f877a0dd.png)
        
    - 나쁜 문자 이동
    
          - 나쁜 문자란 뒤에서부터 문자를 검사했을 때 일치하지 않는 문자열이라고 합니다. step 1의 빨간 문자열이 나쁜 문자열입니다.
          
          - 이 방법을 사용할 수가 없는 경우가 있는데 그럴 때는 착한접미부 이동을 사용합니다.
          
          - 실행 순서
          
              1. 뒤에서부터 검사했을 때 일치하지 않는 문자열을 찾습니다.
              2. 패턴에서 일치하지 않는 문자열에서 앞에 문자열을 검사해서 본문의 문자와 일치하는 물자를 찾습니다.
              3. 본문의 나쁜 문자와 일치하는 패턴의 문자를 위치를 같게 옮겨줍니다.
              4. 반복
              
    - 착한접미부 이동
    
          - 착한 접미부란 뒤에서부터 검사했을 때 일치하는 가장 긴 문자열입니다. step 2의 빨간 문자열이 착한 접미부라고 볼 수 있습니다.
          
          - 패턴이 일치할 때 사용하는 방법과 일치하지 않을떄 사용하는 방법 2가지가 있습니다.
          
          - 패턴 일치 실행 순서
              
              1. 뒤에서부터 검사했을 때 일치하는 가장 긴 문자열을 찾습니다.
              2. 그 뒤의 패턴에서 1에서 얻은 문자열과 같은 패턴을 찾습니다.
              3. 착한 접미부와 뒤의 패턴과 일치하는 부분을 같게 옮겨줍니다.
              4. 반복
          
          - 패턴이 불일치 할 때 실행순서
              
              1. 뒤에서부터 검사했을 때 일치하는 가장 긴 문자열을 찾습니다.           
              2. 그 뒤의 패턴에서 1에서 얻은 문자열과 같은 패턴을 찾을 수가 없습니다!            
              3. 1에서 얻은 문자열에서 왼쪽부터 하나씩 줄여가면서 반복 조사합니다. 
              4. 예 ) abc → 없음 → bc → 없음 → c → 검사 중에 발견
              5. 그런데도 완전 불일치일 경우에는 본문 문자열을 통째로 옮깁니다. (해당 문자열은 일치하지 않는다고 판단)
              
    - 최악의 경우 *O*(*N*)이지만 **평균 *O*(*N*/*M*)의 시간복잡도**를 가진다고 합니다.
