[1. 버블 정렬](#1-버블-정렬)

[2. 선택 정렬](#2-선택-정렬)

[3. 삽입 정렬](#3-삽입-정렬)

[4. 퀵 정렬](#4-퀵-정렬)

[5. 합병 정렬](#5-합병-정렬)

[6. 시간복잡도 표](#6-시간복잡도-표)


- ### 1. 버블 정렬
    - 첫번째 값부터 오른쪽 값과 비교해서 더 크면 서로 위치를 바꾸면서 정렬한다
    - 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다
    - 시간복잡도 :  O(n^2)
    - 공간복잡도 :  O(n)
- ### 2. 선택 정렬
    - 배열에서 가장 작은 값을 찾은 다음 i번쨰 값과 비교 후 더 작을 경우 교체한다.
    - 정렬을 위한 비교 횟수는 많지만, Bubble Sort에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다.
    - **불안정 정렬(Unstable Sort)** 이다.
    - 시간복잡도 :  O(n^2)
    - 공간복잡도 :  O(n)
- ### 3. 삽입 정렬
    - i+1번째 값부터 끝까지 수행한다. 왼쪽의 모든 값과 비교해서 더 작다면 작은 값을 앞의 위치로 옮겨준다
    - 최선의 경우는 **O(n)**의 시간복잡도를 갖고, 평균과 최악의 경우 **O(n^2)**
     의 시간복잡도를 갖게 된다.
    - **안정 정렬(Stable Sort)**이다
    - 삽입 정렬이나 버블 정렬에 비교해 상대적으로 빠르다
    - 시간복잡도 : 평균, 최악/O(n^2), 최선/O(n)
    - 공간복잡도 :  O(n)
- ### 4. 퀵 정렬
    - 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
    - 불안정 정렬에 속한다. 매우 빠른 수행속도를 자랑한다
    - 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
    - 시간복잡도 :  평균,최선/O(nlog₂n), 최악/O(n^2)
    - 공간복잡도 :  O(n)
- ### 5. 합병 정렬
  - 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
  - 안정 정렬 에 속하며, 분할 정복 알고리즘의 하나 이다.
  - 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다
  - 시간복잡도 :  O(nlog₂n)
  - 공간복잡도 :  O(n)

- ### 6. 시간복잡도 표
  | 이름 | 최선 | 평균 | 최악 |
  | --- | --- | --- | --- |
  | 버블정렬 | O(n^2) | O(n^2) | O(n^2) |
  | 선택정렬 | O(n^2) | O(n^2) | O(n^2) |
  | 삽입정렬 | O(n) | O(n^2) | O(n^2) |
  | 퀵 정렬 | O(nlog₂n) | O(nlog₂n) | O(n^2) |
  | 합병 정렬 | O(nlog₂n) | O(nlog₂n) | O(nlog₂n) |
